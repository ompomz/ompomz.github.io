<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr フォローセットエディター（プロフィール名表示）</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f4f8;
            color: #333;
            padding: 20px;
            max-width: 800px;
            margin: auto;
        }
        h1 {
            color: #2c3e50;
        }
        #controls {
            margin-bottom: 20px;
        }
        #event-select {
            padding: 8px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            margin-right: 10px;
        }
        #profiles-container {
            list-style: none;
            padding: 0;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .profile-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid #eee;
            cursor: move;
            transition: background-color 0.2s;
        }
        .profile-item:last-child {
            border-bottom: none;
        }
        .profile-item:hover {
            background-color: #f9f9f9;
        }
        .profile-info {
            display: flex;
            flex-direction: column;
            margin-left: 10px;
        }
        .profile-name {
            font-weight: bold;
            font-size: 1.1em;
        }
        .profile-pubkey {
            font-family: monospace;
            font-size: 0.9em;
            color: #666;
            word-break: break-all;
        }
        .drag-handle {
            cursor: grab;
            margin-right: 10px;
            font-size: 1.2em;
        }
        button {
            padding: 10px 15px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 10px;
            margin-right: 10px; /* ボタン間にスペースを追加 */
        }
        #load-button {
            background-color: #3498db;
            color: white;
        }
        #load-button:hover {
            background-color: #2980b9;
        }
        #load-private-button { /* 新しいボタンのスタイル */
            background-color: #e67e22;
            color: white;
        }
        #load-private-button:hover {
            background-color: #d35400;
        }
        #save-button {
            background-color: #2ecc71;
            color: white;
        }
        #save-button:hover {
            background-color: #27ae60;
        }
        .hidden {
            display: none;
        }
        .info-text {
            color: #888;
            margin-top: 20px;
        }
        .sortable-ghost {
            opacity: 0.5;
            background-color: #e0f7fa;
        }
        .event-info {
            font-size: 0.9em;
            color: #555;
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <h1>Nostr フォローセットエディター</h1>

    <div id="controls">
        <button id="load-button">フォローリストを読み込む</button>
        <button id="load-private-button">非公開リストを読み込む</button>
        <div id="event-selector-container" class="hidden">
            <p>編集するリストを選択してください：</p>
            <select id="event-select"></select>
            <p class="event-info"></p>
        </div>
        <button id="save-button" class="hidden">変更を保存する</button>
        <p class="info-text">※ NIP-07対応の拡張機能と `wss://relay.nostr.band` への接続が必要です。</p>
    </div>

    <ul id="profiles-container">
        </ul>

    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const profilesContainer = document.getElementById('profiles-container');
            const loadButton = document.getElementById('load-button');
            const loadPrivateButton = document.getElementById('load-private-button');
            const saveButton = document.getElementById('save-button');
            const eventSelect = document.getElementById('event-select');
            const eventSelectorContainer = document.getElementById('event-selector-container');
            const eventInfo = document.querySelector('.event-info');

            const RELAY_URL = 'wss://relay.nostr.band';
            let allEvents = [];
            let currentEvent = null;
            let isPrivateList = false; // 非公開リストかどうかを追跡するフラグ
            let profileCache = {}; // プロフィール情報をキャッシュするオブジェクト

            // Sortable.js を初期化
            new Sortable(profilesContainer, {
                animation: 150,
                ghostClass: 'sortable-ghost'
            });

            // フォローリストの読み込み処理 (kind:30000, 公開リスト)
            loadButton.addEventListener('click', async () => {
                if (!window.nostr) {
                    alert('NIP-07対応の拡張機能が見つかりません。');
                    return;
                }
                await loadEvents([30000], false);
            });
            
            // 非公開リストの読み込み処理 (kind:10000, 暗号化リスト)
            loadPrivateButton.addEventListener('click', async () => {
                if (!window.nostr || !window.nostr.nip04) {
                    alert('NIP-07およびNIP-04に対応した拡張機能が必要です。');
                    return;
                }
                await loadEvents([10000], true);
            });

            // イベントを読み込む共通関数
            async function loadEvents(kinds, isPrivate) {
                allEvents = [];
                profilesContainer.innerHTML = '';
                eventSelectorContainer.classList.add('hidden');
                saveButton.classList.add('hidden');
                isPrivateList = isPrivate;

                const pubkey = await window.nostr.getPublicKey();
                const ws = new WebSocket(RELAY_URL);

                ws.onopen = () => {
                    const filter = {
                        kinds: kinds,
                        authors: [pubkey]
                    };
                    ws.send(JSON.stringify(["REQ", "my-follow-set-req", filter]));
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data[0] === "EVENT") {
                        const nostrEvent = data[2];
                        allEvents.push(nostrEvent);
                    } else if (data[0] === "EOSE") {
                        ws.close();
                        if (allEvents.length === 0) {
                            alert(isPrivateList ? 'kind:10000の非公開リストが見つかりませんでした。' : 'kind:30000のフォローリストが見つかりませんでした。');
                            return;
                        }
                        
                        renderEventSelector(allEvents);
                        eventSelectorContainer.classList.remove('hidden');
                        saveButton.classList.remove('hidden');
                    }
                };
            }

            // イベント選択肢をレンダリングする関数
            function renderEventSelector(events) {
                eventSelect.innerHTML = '';
                events.forEach(event => {
                    const option = document.createElement('option');
                    const dTag = event.tags.find(tag => tag[0] === 'd');
                    const titleTag = event.tags.find(tag => tag[0] === 'title');
                    const eventTitle = titleTag ? titleTag[1] : (dTag ? dTag[1] : `ID: ${event.id.slice(0, 8)}...`);
                    
                    option.textContent = `${isPrivateList ? '🔒' : ''} ${eventTitle}`;
                    option.value = event.id;
                    eventSelect.appendChild(option);
                });
                
                eventSelect.dispatchEvent(new Event('change'));
            }

            // イベントが選択されたときの処理
            eventSelect.addEventListener('change', async () => {
                const selectedId = eventSelect.value;
                currentEvent = allEvents.find(event => event.id === selectedId);

                if (currentEvent) {
                    profilesContainer.innerHTML = '<li>読み込み中...</li>';

                    let pubkeys = [];
                    // 非公開リストの場合は復号
                    if (isPrivateList) {
                        try {
                            const decryptedContent = await window.nostr.nip04.decrypt(currentEvent.pubkey, currentEvent.content);
                            const decryptedEvent = JSON.parse(decryptedContent);
                            pubkeys = decryptedEvent.p;
                        } catch (e) {
                            alert('非公開リストの復号に失敗しました。');
                            profilesContainer.innerHTML = '<li>復号に失敗しました。</li>';
                            console.error('Decryption failed:', e);
                            return;
                        }
                    } else {
                        // 公開リストの場合はタグから抽出
                        pubkeys = currentEvent.tags.filter(tag => tag[0] === 'p').map(tag => tag[1]);
                    }
                    
                    // プロフィール情報を取得
                    await fetchProfiles(pubkeys);
                    
                    // プロフィールをレンダリング
                    renderProfiles(pubkeys);
                    
                    const dTag = currentEvent.tags.find(tag => tag[0] === 'd');
                    const titleTag = currentEvent.tags.find(tag => tag[0] === 'title');
                    eventInfo.textContent = `d-tag: ${dTag ? dTag[1] : 'なし'} / title-tag: ${titleTag ? titleTag[1] : 'なし'}`;
                }
            });

            // プロフィール情報を取得する関数
            async function fetchProfiles(pubkeys) {
                const missingPubkeys = pubkeys.filter(pubkey => !profileCache[pubkey]);

                if (missingPubkeys.length === 0) return;

                return new Promise((resolve) => {
                    const ws = new WebSocket(RELAY_URL);
                    ws.onopen = () => {
                        const filter = {
                            kinds: [0],
                            authors: missingPubkeys
                        };
                        ws.send(JSON.stringify(["REQ", "profile-req", filter]));
                    };
                    
                    ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        if (data[0] === "EVENT") {
                            const profileEvent = data[2];
                            try {
                                const profileData = JSON.parse(profileEvent.content);
                                profileCache[profileEvent.pubkey] = profileData;
                            } catch (e) {
                                console.error("Failed to parse profile content", e);
                            }
                        } else if (data[0] === "EOSE") {
                            ws.close();
                            resolve();
                        }
                    };
                });
            }

            // プロフィールをレンダリングする関数
            function renderProfiles(pubkeys) {
                profilesContainer.innerHTML = '';
                pubkeys.forEach(pubkey => {
                    const li = document.createElement('li');
                    li.className = 'profile-item';
                    li.dataset.pubkey = pubkey;

                    const name = profileCache[pubkey] ? profileCache[pubkey].name : null;
                    const displayName = name || `(名無し)`;

                    li.innerHTML = `
                        <span class="drag-handle">☰</span>
                        <div class="profile-info">
                            <span class="profile-name">${displayName}</span>
                            <span class="profile-pubkey">${pubkey.slice(0, 8)}...${pubkey.slice(-8)}</span>
                        </div>
                    `;
                    profilesContainer.appendChild(li);
                });
            }

            // 変更を保存する処理
            saveButton.addEventListener('click', async () => {
                if (!currentEvent) {
                    alert('先にフォローリストを読み込んでください。');
                    return;
                }

                const updatedPubkeys = Array.from(profilesContainer.children).map(li => li.dataset.pubkey);
                
                let newEvent;
                const newTags = currentEvent.tags.filter(tag => tag[0] !== 'p' && tag[0] !== 'e' && tag[0] !== 'd');
                
                if (isPrivateList) {
                    // 非公開リストの場合は、公開鍵リストをJSON形式で暗号化
                    const encryptedContent = await window.nostr.nip04.encrypt(currentEvent.pubkey, JSON.stringify({ p: updatedPubkeys }));
                    newEvent = {
                        kind: 10000,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: newTags,
                        content: encryptedContent
                    };
                } else {
                    // 公開リストの場合は、公開鍵リストをpタグに追加
                    const pTags = updatedPubkeys.map(pubkey => ["p", pubkey]);
                    newEvent = {
                        kind: 30000,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: newTags.concat(pTags),
                        content: ""
                    };
                }
                
                // 元のイベントのdタグを継承
                const dTag = currentEvent.tags.find(tag => tag[0] === 'd');
                if (dTag) {
                    newEvent.tags.push(dTag);
                }

                try {
                    const signedEvent = await window.nostr.signEvent(newEvent);
                    const ws = new WebSocket(RELAY_URL);
                    ws.onopen = () => {
                        ws.send(JSON.stringify(["EVENT", signedEvent]));
                        console.log('イベントを公開しました:', signedEvent);
                        alert('フォローリストが保存されました！');
                        ws.close();
                    };
                } catch (error) {
                    console.error('署名または公開に失敗しました:', error);
                    alert('保存に失敗しました。');
                }
            });
        });
    </script>
</body>
</html>
