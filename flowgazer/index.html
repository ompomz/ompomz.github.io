<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>flowgazer -kindness edition-</title>
  <link rel="stylesheet" href="style.css">
  <script src="https://unpkg.com/nostr-tools/lib/nostr.bundle.js"></script>
  <script>
    // おなじみのユーティリティ関数
    String.prototype.padStart = String.prototype.padStart ? String.prototype.padStart : function(targetLength, padString) {
      targetLength = Math.floor(targetLength) || 0;
      if(targetLength < this.length) return String(this);
      padString = padString ? String(padString) : " ";
      var pad = "";
      var len = targetLength - this.length;
      var i = 0;
      while(pad.length < len) {
        if(!padString[i]) {
          i = 0;
        }
        pad += padString[i];
        i++;
      }
      return pad + String(this).slice(0);
    };

    function getLanguage() {
      return (window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage).substring(0, 2);
    }

    // 鍵ペア生成関数
    function generateKeypair() {
      const seckey = window.NostrTools.generateSecretKey();
      const pubkey = window.NostrTools.getPublicKey(seckey);
      return {
        seckeyHex: seckey,
        pubkeyHex: pubkey,
        nsec: window.NostrTools.nip19.nsecEncode(seckey),
        npub: window.NostrTools.nip19.npubEncode(pubkey)
      };
    }
  </script>
</head>
<body>

  <h4>flowgazer -kindness edition-</h4>
  <a href="index2.html" class="nostr-link">Nostrってなに？</a>
  <p class="header-intro">Nostrを「体験」してみて！！このページでは、鍵を作って・投稿して・タイムラインを見ることができます。
  </p>

    <div>
    <button id="generate-keypair" class="full-width">新しい鍵ペアを生成して試してみる</button>
    <div id="keypair-area" class="hidden">
      <p><span class="key-label">秘密鍵（nsec）:</span><br>
        <input id="nsec" type="password" placeholder="nsec1..." class="full-width">
      </p>
      <p><span class="key-label">公開鍵（npub）:</span><br>
        <a id="npub-link" class="npub-link" target="_blank" rel="noreferrer" style="display: none;"></a>
      </p>
    </div>
    <p id="warning-message" class="hidden">
      ⚠️秘密鍵を紛失すると、二度とこのアカウントで投稿やログインができなくなります。<br>
      ⚠️秘密鍵は絶対に誰にも教えないでください。
    </p>
    <textarea id="new-post-content" rows="4" placeholder="いまなにしてる？" class="full-width mt-1"></textarea>
    <button id="send-new-post" class="full-width">投稿</button>
  </div>
  
    <div id="settings-toggle-area">
    <button id="show-settings">詳細設定を表示</button>
    <button id="hide-settings" class="hidden">詳細設定を隠す</button>
  </div>
  <div id="advanced-settings" class="hidden"><p><span class="key-label">すでに秘密鍵を持っている方</span><br>
      <input id="existing-nsec-input" type="password" placeholder="nsec1..." class="full-width">
    </p>
    <div style="margin-bottom: 1rem;"><label for="hex-filter">投稿者pubkeyしぼりこみ（hex, npub, nprofile）</label>
      <p>複数の鍵は、カンマ、改行、スペースで区切れます</p>
      <textarea id="hex-filter" rows="3" cols="50" placeholder="hex1, npub1..., ..."></textarea>
      <button id="apply-filter">適用</button>
    </div>
    <div style="margin-bottom: 1rem;"><label for="relay-url">リレーURL</label>
      <input id="relay-url" type="text" class="full-width">
      <button id="subscribe-relay">接続</button>
    </div>
  </div>
  
  <hr />

  <ul id="timeline"></ul>

  <button type="button" id="load-more" class="loading full-width">もっと見る</button>

  <script>
    // ここから既存のスクリプトを貼り付け
    function formatTimestamp(date) {
      return String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0") + ":" + String(date.getSeconds()).padStart(2, "0");
    }

    function findTagWithValue(tags, name, value, extraPred) {
      for (var i = 0; i < tags.length; i++) {
        var tag = tags[i];
        if (tag[0] === name && tag[1] === value && (extraPred ? extraPred(tag) : true)) {  
          return tag;
        }
      }
      return undefined;
    }

    function baseEventView() {
      var li = document.createElement("li");
      li.classList.add("event");
      return li;
    }

    function externalLink(url, text) {
      var a = document.createElement("a");
      a.href = url;
      a.target = "_blank";
      a.rel = "noreferrer";
      a.textContent = text;
      return a;
    }

    function timestampView(unixtime) {
      var ts = new Date(unixtime * 1000);
      var timeElem = document.createElement("time");
      timeElem.setAttribute("datetime", ts.toISOString());
      timeElem.textContent = "[" + formatTimestamp(ts) + "]";
      return timeElem;
    }
      
    function pubkeyView(pubkey) {
      var npub = window.NostrTools.nip19.npubEncode(pubkey);
      var displayName = profiles[pubkey] && profiles[pubkey].name ? profiles[pubkey].name : pubkey.substring(0, 8);
      var sanitizedName = displayName.replace(/\p{Emoji_Presentation}/gu, "");
        if (sanitizedName.length === 0) {
            sanitizedName = pubkey.substring(0, 8);
        } else if (sanitizedName.length > 8) {
            sanitizedName = sanitizedName.substring(0, 8);
        }
      var a = externalLink("https://njump.me/" + npub, sanitizedName);
            a.classList.add("pubkey-ref");
            
      return a;
    }

    function metadataView(nostrEv) {
      var view = document.createElement("span");
      view.appendChild(timestampView(nostrEv.created_at));
      view.appendChild(document.createTextNode(" "));
      view.appendChild(pubkeyView(nostrEv.pubkey));
      view.appendChild(document.createTextNode(" > "));
      return view;
    }

    var contentRefPattern = /(https?:\/\/[^\s]+)|(nostr:[\w]+1[ac-hj-np-z02-9]+)|(:[_a-zA-Z0-9]+:)/;  

    function indexOfFirstUnmatchingCloseParen(url) {
      var nest = 0;
      for (var i = 0; i < url.length; i++) {
        var c = url.charAt(i);
        if (c === "(") {
          nest++;
        } else if (c === ")") {
          if (nest <= 0) {
            return i;
          }
          nest--;
        }
      }
      return -1;
    }

    function urlLinkElems(url) {
      var splitIdx = indexOfFirstUnmatchingCloseParen(url);
      var finalUrl = splitIdx === -1 ? url : url.substring(0, splitIdx);
      var rest = splitIdx === -1 ? "" : url.substring(splitIdx);

      var link = externalLink(finalUrl, finalUrl);

      if (rest.length === 0) {
        return [link];
      }
      var restSpan = document.createElement("span");
      restSpan.textContent = rest;
      return [link, restSpan];
    }

    function extractEventRef(nip19Decoded) {
      switch (nip19Decoded.type) {
        case "nevent":
          return { id: nip19Decoded.data.id, author: nip19Decoded.data.author };
        case "note":
          return { id: nip19Decoded.data }
        default:
          return undefined;
      }
    }
    function extractReplyRef(tags) {
      var root; // first "root" p-tag

      for (var i = 0; i < tags.length; i++) {
        var tag = tags[i];
        if (tag[0] !== "e") {
          continue;
        }
        if (tag[3] === "reply" && typeof tag[1] === "string") {
          return { id: tag[1], author: typeof tag[4] === "string" ? tag[4] : undefined };
        }
        if (root === undefined && tag[3] === "root" && typeof tag[1] === "string") {
          root = { id: tag[1], author: typeof tag[4] === "string" ? tag[4] : undefined };
        }
      }
      // no "reply" p-tag
      return root;
    }

    function nostrRefLink(nip19Id, idType) {
      var abbrId = nip19Id.substring(0, idType.length + 8) + "...";
      var a = externalLink("https://njump.me/" + nip19Id, "nostr:" + abbrId);
      a.classList.add("nostr-ref");
      return a;
    }

    function nostrEventRefLink(nip19id, idType, hexEventId) {
    var abbrId = nip19id.substring(0, idType.length + 8) + "...";
    var a = document.createElement("a");
    a.textContent = "nostr:" + abbrId;
    a.classList.add("nostr-ref");

    if (document.getElementById(hexEventId)) {
      a.href = "#" + hexEventId;
    } else {
      a.href = "https://njump.me/" + nip19id;
      a.target = "_blank";
      a.rel = "noreferrer";
    }
    return a;
    }

    var lastHighlightedEventId;
    window.addEventListener("hashchange", function() {
      if (window.location.hash.length === 0) {
        return;
      }
      var hash = window.location.hash.substring(1);
      if (hash.length === 0) {
        return;
      }
      if (lastHighlightedEventId) {
        var highlighted = document.getElementById(lastHighlightedEventId);
        if (highlighted) {
          highlighted.classList.remove("event-highlighted");
        }
      }
      var target = document.getElementById(hash);
      if (!target) {
        return;
      }
      lastHighlightedEventId = hash;
      target.classList.add("event-highlighted");
    });

    function pubkeyMention(pubkey) {
      var pubkeyRef = pubkeyView(pubkey);
      pubkeyRef.classList.add("pubkey-mention");
      return pubkeyRef;
    }

    function referentAuthor(pubkey) {
      var span = document.createElement("span");
      span.appendChild(document.createTextNode(" by "));
      span.appendChild(pubkeyView(pubkey));
      return span;
    }

    function inReplyToElems(nostrEv) {
      var replyRef = extractReplyRef(nostrEv.tags);
      if (replyRef === undefined) {
        return [];
      }
      
      var replySuffix = document.createElement("span");
      replySuffix.textContent = "<< ";
      replySuffix.classList.add("reply-suffix");

      var nevent = window.NostrTools.nip19.neventEncode(replyRef);
      var replyLink = nostrEventRefLink(nevent, "nevent", replyRef.id);

      if (!replyRef.author) {
        return [replyLink, replySuffix];
      }
      return [replyLink, referentAuthor(replyRef.author), replySuffix];
    }

    function postQuotationElems(nip19Id, idType, hexEventId, author) {
      var prefix = document.createElement("span");
      prefix.textContent = "QP: ";
      prefix.classList.add("quote-prefix");

      var link = nostrEventRefLink(nip19Id, idType, hexEventId);

      if (!author) {
        return [prefix, link];
      }
      return [prefix, link, referentAuthor(author)];
    }

    function nostrUriElems(ref, nostrEv) {
      var nip19Id = ref.substring(6);
      var dec;
      try {
        dec = window.NostrTools.nip19.decode(nip19Id);
      } catch (err) {
        console.error("failed to decode NIP-19 ID:", err);
        return [document.createTextNode(ref)];
      }

      switch (dec.type) {
        case "npub":
          return [pubkeyMention(dec.data)];
        case "nprofile":
          return [pubkeyMention(dec.data.pubkey)];

        case "note":
        case "nevent":
          var evRef = extractEventRef(dec);
          if (ref === undefined) {
            console.error("unreachable");
            return [nostrRefLink(nip19Id, dec.type)];
          }
          var mentionTag = findTagWithValue(nostrEv.tags, "e", evRef.id, function(t) { t[3] === "mention" });
          var author = (mentionTag && mentionTag[4]) || evRef.author;
          return postQuotationElems(nip19Id, dec.type, evRef.id, evRef.author);

        default:
          return [nostrRefLink(nip19Id, dec.type)];
      }
    }

    function customEmojiElems(shortcode, nostrEv) {
      var emojiName = shortcode.substring(1, shortcode.length - 1);
      for (var i = 0; i < nostrEv.tags.length; i++) {
        var tag = nostrEv.tags[i];
        if (tag[0] === "emoji" && tag[1] === emojiName && typeof tag[2] === "string") {
          var img = document.createElement('img');
          img.src = tag[2];
          img.alt = shortcode;
          img.classList.add("custom-emoji");
          return [img];
        }
      }
      return [document.createTextNode(shortcode)];
    }

    function postEventView(nostrEv) {
      var view = baseEventView();
      view.id = nostrEv.id;
      view.classList.add("event-post");
      
      view.appendChild(metadataView(nostrEv));

      inReplyToElems(nostrEv).forEach(function(e) {
        view.appendChild(e);
      });

      var contentElems = nostrEv.content.split(contentRefPattern)
        .filter(function(s) {
          return s !== undefined && s.length > 0;
        })
        .map(function(s) {
          if (s.indexOf("http") === 0) {
            return urlLinkElems(s);
          } else if (s.indexOf("nostr:") === 0) {
            return nostrUriElems(s, nostrEv);
          } else if (s.charAt(0) === ":" && s.charAt(s.length - 1) === ":") {
            return customEmojiElems(s, nostrEv);
          } else {
            return [document.createTextNode(s)];
          }
        });
      contentElems.forEach(function(elems) {
        elems.forEach(function(e) {
          view.appendChild(e);
        });
      });

      return view;
    }

    function repostEventView(nostrEv) {
      var targetPostId;
      var targetPostAuthor;
      for (var i = 0; i < nostrEv.tags.length; i++) {
        var tag = nostrEv.tags[i];
        if (tag[0] === "e" && typeof tag[1] === "string") {
          targetPostId = tag[1];
        }
        if (tag[0] === "p" && typeof tag[1] === "string") {
          targetPostAuthor = tag[1];
        }
        if (targetPostId && targetPostAuthor) {
          break;
        }
      }
      if (targetPostId === undefined) {
        console.error("repost without target post ID:", nostrEv);
        return undefined;
      }

      var view = baseEventView();
      view.classList.add("event-repost");

      view.appendChild(metadataView(nostrEv));

      var repostPrefix = document.createElement("span");
      repostPrefix.textContent = "RP: ";
      repostPrefix.classList.add("repost-prefix");
      
      var nevent = window.NostrTools.nip19.neventEncode({ id: targetPostId });
      var repostLink = nostrEventRefLink(nevent, "nevent", targetPostId);

      view.appendChild(repostPrefix);
      view.appendChild(repostLink);
      if (targetPostAuthor) {
        view.appendChild(referentAuthor(targetPostAuthor));
      }
      return view;
    }

    var supportedKinds = [1, 6];
    var profiles = {};
    var events = {};
    var filteredAuthors = null;

    function onEvent(nostrEv, prepend) {
      if (!window.NostrTools.verifyEvent(nostrEv)) {
        console.error("nostr event with invalid signature:", nostrEv);
        return;
      }
      if (nostrEv.kind === 0) {
          try {
              profiles[nostrEv.pubkey] = JSON.parse(nostrEv.content);
              refreshTimeline();
          } catch (e) {
            console.error("Failed to parse profile content:", e);
          }
          return;
      }
      if (supportedKinds.indexOf(nostrEv.kind) === -1) {
        console.error("unsupported kind:", nostrEv.kind);
        return;
      }
      if (events[nostrEv.id]) {
          return;
      }
      events[nostrEv.id] = nostrEv;
      oldestCreatedAt = Math.min(oldestCreatedAt, nostrEv.created_at);
      pubkeysToFetch.add(nostrEv.pubkey);
      var eventView;
      switch (nostrEv.kind) {
      case 1:
        eventView = postEventView(nostrEv);
        break;
      case 6:
        eventView = repostEventView(nostrEv);
        break;
      default:
        return;
      }
      if (eventView === undefined) {
        return;
      }
      if (prepend) {
        timeline.insertBefore(eventView, timeline.firstChild);
      } else {
        timeline.appendChild(eventView);
      }
    }
      
    function refreshTimeline() {
        while (timeline.firstChild) {
            timeline.removeChild(timeline.firstChild);
        }
        var sortedEvents = Object.values(events).sort((a, b) => b.created_at - a.created_at);
        sortedEvents.forEach(e => {
            if (e.kind === 1) {
                timeline.appendChild(postEventView(e));
            } else if (e.kind === 6) {
                timeline.appendChild(repostEventView(e));
            }
        });
    }

    function onWSClose() {
      alert("Relay connection closed");
    }

    var MAIN_SUB_ID = "motherfuncking-main-sub";
    var MORE_POSTS_SUB_ID = "motherfuncking-more-posts";
    var PROFILE_SUB_ID = "motherfuncking-profile-sub";
      
    var pubkeysToFetch = new Set();

    function isKnownSubId(subId) {
      return subId === MAIN_SUB_ID || subId === MORE_POSTS_SUB_ID || subId === PROFILE_SUB_ID;
    }
    function shouldPrependPost(subId, afterEose) {
      return subId === MAIN_SUB_ID && afterEose;
    }

    var relayWS;
    function subscribeRelay(relayUrl, authors) {
      if (relayWS) {
        while (timeline.firstChild) {
          timeline.removeChild(timeline.firstChild);
        }
        relayWS.removeEventListener("close", onWSClose);
        relayWS.close();
      }
      
      try {
        relayWS = new WebSocket(relayUrl);
      } catch (err) {
        console.error("failed to connect to relay:", err);
        alert("Failed to connect to relay:", relayUrl);
        return;
      }
      
      events = {};
      pubkeysToFetch = new Set();
      oldestCreatedAt = Number.MAX_VALUE;

      var afterEose = false;
      var filter = { kinds: [1, 6], limit: 50 };
      if (authors && authors.length > 0) {
        filter.authors = authors;
      }

      relayWS.addEventListener("open", function() {
        relayWS.send(
          JSON.stringify(["REQ", MAIN_SUB_ID, filter])
        );
      });

      relayWS.addEventListener("message", function(ev) {
        try {
          var r2cMsg = JSON.parse(ev.data);
          switch (r2cMsg[0]) {
          case "EVENT":
            var subId = r2cMsg[1];
            if (!isKnownSubId(subId)) {
              console.error("unknown subId:", subId);
              return;
            }
            onEvent(r2cMsg[2], shouldPrependPost(subId, afterEose));
            break;
          case "EOSE":
            var subId = r2cMsg[1];
            if (subId === MAIN_SUB_ID) {
              afterEose = true;
              fetchProfiles();
            }
            loadMoreButton.classList.remove("loading");
            break;
          default:
            console.log(r2cMsg);
            break;
          }
        } catch (err) {
          console.error(err);
        }
      });
      relayWS.addEventListener("close", onWSClose);
    }
      
    function fetchProfiles() {
        if (pubkeysToFetch.size === 0) {
            return;
        }
        var profileRelayWS = new WebSocket("wss://relay.nostr.band");
        profileRelayWS.addEventListener("open", function() {
            var pubkeysArray = Array.from(pubkeysToFetch);
            profileRelayWS.send(
                JSON.stringify(["REQ", PROFILE_SUB_ID, { kinds: [0], authors: pubkeysArray }])
            );
        });
        profileRelayWS.addEventListener("message", function(ev) {
            try {
                var r2cMsg = JSON.parse(ev.data);
                switch (r2cMsg[0]) {
                    case "EVENT":
                        var nostrEv = r2cMsg[2];
                        if (nostrEv.kind === 0) {
                            try {
                                var profileContent = JSON.parse(nostrEv.content);
                                profiles[nostrEv.pubkey] = profileContent;
                                pubkeysToFetch.delete(nostrEv.pubkey);
                            } catch (e) {
                                console.error("Failed to parse profile content:", e);
                            }
                        }
                        break;
                    case "EOSE":
                        refreshTimeline();
                        profileRelayWS.close();
                        break;
                }
            } catch (err) {
                console.error(err);
            }
        });
    }

    var timeline = document.getElementById("timeline");
    if (timeline === null) {
      throw new Error("no #timeline");
    }

    var LS_RELAY_URL_KEY = "relayUrl";
    var relayUrlInput = document.getElementById("relay-url");
    var subscribeButton = document.getElementById("subscribe-relay");
    subscribeButton.addEventListener("click", function() {
      var rurl = relayUrlInput.value;
      subscribeRelay(rurl);
      localStorage.setItem(LS_RELAY_URL_KEY, rurl);
    });

    var latestRurl = localStorage.getItem(LS_RELAY_URL_KEY);
    var defaultRurl = getLanguage() === "ja" ? "wss://r.kojira.io" : "wss://nos.lol/";
    var initialRurl = latestRurl || defaultRurl;
    relayUrlInput.value = initialRurl;
    subscribeRelay(initialRurl);

    // 鍵生成
    var generateButton = document.getElementById("generate-keypair");
    var nsecInput = document.getElementById("nsec");
    var npubLink = document.getElementById("npub-link");
    var keypairArea = document.getElementById("keypair-area");
    var warningMessageArea = document.getElementById("warning-message");

    generateButton.addEventListener("click", function() {
      const keys = generateKeypair();
      nsecInput.value = keys.nsec;
      
      npubLink.textContent = keys.npub;
      npubLink.href = "https://nostter.app/" + keys.npub;
      npubLink.style.display = "inline";
      keypairArea.classList.remove("hidden");
      nsecInput.type = "text";
      warningMessageArea.classList.remove('hidden');

      // 詳細設定を非表示にし、入力欄を空にする
      settingsArea.classList.add("hidden");
      existingNsecInput.value = "";
      hideSettingsBtn.classList.add("hidden");
      showSettingsBtn.classList.remove("hidden");
    });

    npubLink.addEventListener("click", function(event) {
      window.open(this.href, "_blank"); // this.hrefでもnpubLink.hrefでもOK
    });

    // 投稿
    var postContentInput = document.getElementById("new-post-content");
    var sendPostButton = document.getElementById("send-new-post");
    var existingNsecInput = document.getElementById("existing-nsec-input");

    function sendeNewPost() {
      // 既存の秘密鍵入力欄の値を優先する
      var nsec = existingNsecInput.value || nsecInput.value;
      var content = postContentInput.value;
      if (!nsec || !content) {
        alert("秘密鍵と投稿内容を入力してください。");
        return;
      }
      try {
        var nsecDecoded = window.NostrTools.nip19.decode(nsec);
        if (nsecDecoded.type !== "nsec") {
          alert("無効な秘密鍵です。");
          return;
        }
        var seckey = nsecDecoded.data;
        var post = {
          kind: 1,
          content: content,
          created_at: Math.floor(Date.now() / 1000),
          tags: [],
        };
        var signedPost = window.NostrTools.finalizeEvent(post, seckey);
        relayWS.send(JSON.stringify(["EVENT", signedPost]));
        postContentInput.value = "";
      } catch (err) {
        console.error(err);
        alert("投稿に失敗しました。");
      }
    }
    sendPostButton.addEventListener("click", sendeNewPost);

    // 詳細設定の表示/非表示
    var showSettingsBtn = document.getElementById("show-settings");
    var hideSettingsBtn = document.getElementById("hide-settings");
    var settingsArea = document.getElementById("advanced-settings");

    showSettingsBtn.addEventListener("click", function() {
        settingsArea.classList.remove("hidden");
        showSettingsBtn.classList.add("hidden");
        hideSettingsBtn.classList.remove("hidden");

        // 鍵ペア生成エリアを非表示にし、入力欄を空にする
        keypairArea.classList.add("hidden");
        warningMessageArea.classList.add("hidden");
        nsecInput.value = "";
    });

    hideSettingsBtn.addEventListener("click", function() {
        settingsArea.classList.add("hidden");
        hideSettingsBtn.classList.add("hidden");
        showSettingsBtn.classList.remove("hidden");
    });
    
    // 絞り込み
    var hexFilterInput = document.getElementById("hex-filter");
    var applyFilterButton = document.getElementById("apply-filter");

    function filterAuthors() {
      var inputText = hexFilterInput.value;
      if (!inputText.trim()) {
        return [];
      }
      var authors = inputText.split(/[ ,　\n]/);
      var filtered = authors.map(function(hex) {
        hex = hex.trim();
        if (hex.startsWith('npub') || hex.startsWith('nprofile')) {
          try {
            var decoded = NostrTools.nip19.decode(hex);
            if (decoded.type === 'npub') {
              return decoded.data;
            } else if (decoded.type === 'nprofile') {
              return decoded.data.pubkey;
            }
          } catch (e) {
            return null;
          }
        }
        return hex.length === 64 && /^[0-9a-fA-F]{64}$/.test(hex) ? hex : null;
      }).filter(Boolean);
      return filtered;
    }

    applyFilterButton.addEventListener("click", function() {
      filteredAuthors = filterAuthors();
      var rurl = relayUrlInput.value;
      subscribeRelay(rurl, filteredAuthors);
    });
      
    var oldestCreatedAt = Number.MAX_VALUE;
    var loadMoreButton = document.getElementById("load-more");

    function fetchMorePosts() {
      if (!relayWS) {
        return;
      }
      loadMoreButton.classList.add("loading");
      var filter = { kinds: [1, 6], limit: 50, until: oldestCreatedAt - 1 };
      if (filteredAuthors && filteredAuthors.length > 0) {
        filter.authors = filteredAuthors;
      }
      relayWS.send(
        JSON.stringify(["REQ", MORE_POSTS_SUB_ID, filter])
      );
    }
    loadMoreButton.addEventListener("click", fetchMorePosts);
  </script>
</body>
</html>
