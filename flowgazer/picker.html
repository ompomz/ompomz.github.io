<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>tool</title>
  <style>
    /* 後でスタイルを追加してください */
  </style>
</head>
<body>
  <h1>tool</h1>
  <section>
    <h2> (kind:3)</h2>
    <input type="text" id="follow-input" placeholder="公開鍵 (hex / npub1 / NIP-05)">
    <button onclick="getFollowList()">取得</button>
    <br><br>
    <label for="extracted-follows">抽出された公開鍵:</label><br>
    <textarea id="extracted-follows" rows="5" cols="60"></textarea>
  </section>

  <hr>

  <section>
    <h2>プロフィール取得 (kind:0)</h2>
    <textarea id="pubkey-textarea" rows="3" cols="60" placeholder="公開鍵を入力（複数可）"></textarea><br>
    <button onclick="getProfiles()">取得</button>
    <button onclick="checkAll(true)">全部チェック</button>
    <button onclick="checkAll(false)">全部はずす</button>
    <button onclick="extractSelected()">抽出</button>
    <button onclick="copyHexes()">コピー↓</button><br>
    <label for="extracted-hexes">抽出された公開鍵:</label><br>
    <textarea id="extracted-hexes" rows="1" cols="60"></textarea>
    <br><br>
    <table border="1" id="profile-table">
      <thead>
        <tr><th>選択</th><th>名前</th><th>公開鍵 (hex)</th></tr>
      </thead>
      <tbody></tbody>
    </table>    
  </section>

  <script src="https://cdn.jsdelivr.net/npm/nostr-tools@2.1.2/lib/nostr.bundle.min.js"></script>
  <script>
    const { bech32 } = window.NostrTools.nip19;
    const relayURL = "wss://relay.nostr.band";

    async function resolveNip05(nip05) {
      const parts = nip05.split('@');
      if (parts.length !== 2) return null;

      const [name, domain] = parts;
      try {
        const response = await fetch(`https://${domain}/.well-known/nostr.json?name=${name}`);
        const data = await response.json();
        return data.names[name] || null;
      } catch (e) {
        console.error(`NIP-05アドレスの解決に失敗しました: ${nip05}`, e);
        return null;
      }
    }

    function bech32Decode(npub) {
      const { data } = NostrTools.nip19.decode(npub);
      return data;
    }

    async function normalizePubkeys(input) {
      const keys = input.split(/[\s,]+/).filter(Boolean);
      const resolvedKeys = await Promise.all(keys.map(async k => {
        if (k.startsWith("npub1")) {
          try {
            return bech32Decode(k);
          } catch {
            return null;
          }
        } else if (/^[a-f0-9]{64}$/i.test(k)) {
          return k;
        } else if (k.includes('@')) {
          return await resolveNip05(k);
        } else {
          return null;
        }
      }));
      return resolvedKeys.filter(Boolean);
    }

    async function getFollowList() {
      const input = document.getElementById("follow-input").value.trim();
      const pubkey = (await normalizePubkeys(input))[0];
      if (!pubkey) return alert("無効な公開鍵です");

      const socket = new WebSocket(relayURL);
      socket.onopen = () => {
        const req = ["REQ", "follow-req", { kinds: [3], authors: [pubkey], limit: 1 }];
        socket.send(JSON.stringify(req));
      };
      socket.onmessage = (event) => {
        const [type, , eventData] = JSON.parse(event.data);
        if (type === "EVENT") {
          const follows = eventData.tags
            .filter(tag => tag[0] === "p")
            .map(tag => tag[1]);
          document.getElementById("extracted-follows").value = follows.join(",");
          socket.close();
        }
      };
    }

    async function getProfiles() {
      const input = document.getElementById("pubkey-textarea").value;
      const pubkeys = await normalizePubkeys(input);
      if (pubkeys.length === 0) return alert("有効な公開鍵がありません");
      
      // テーブルの内容をクリア
      document.querySelector("#profile-table tbody").innerHTML = '';

      const socket = new WebSocket(relayURL);
      socket.onopen = () => {
        const req = ["REQ", "profile-req", { kinds: [0], authors: pubkeys }];
        socket.send(JSON.stringify(req));
      };
      socket.onmessage = (event) => {
        const [type, , eventData] = JSON.parse(event.data);
        if (type === "EVENT") {
          try {
            const profile = JSON.parse(eventData.content);
            const name = profile.name || "(未設定)";
            const hex = eventData.pubkey;
            const row = document.createElement("tr");
            row.innerHTML = `<td><input type="checkbox" value="${hex}"></td><td>${name}</td><td>${hex}</td>`;
            document.querySelector("#profile-table tbody").appendChild(row);
          } catch {
            console.warn("プロフィール解析失敗");
          }
        }
      };
    }

    function checkAll(flag) {
      document.querySelectorAll("#profile-table tbody input[type='checkbox']").forEach(cb => cb.checked = flag);
    }

    function extractSelected() {
      const selected = Array.from(document.querySelectorAll("#profile-table tbody input[type='checkbox']:checked"))
        .map(cb => cb.value);
      document.getElementById("extracted-hexes").value = selected.join(",");
    }

    function copyHexes() {
      const textarea = document.getElementById("extracted-hexes");
      textarea.select();
      document.execCommand("copy");
      alert("コピーしました！");
    }
  </script>
</body>
</html>
